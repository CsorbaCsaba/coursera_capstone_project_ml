
# **Final assigment - Capstone project**

## Table of contents <a name="top"></a>
* [Introduction](#introduction)
* [Data description](#data)
* [Get the data](#data2)
* [Methodology](#methodology)
* [Analysis / Exploration](#analysis) 
  1. [Mapping London](#mappinglondon)
  2. [Explore Neighborhoods in London](#londonneighborhoods)
  3. [Neighborhood Analysis](#neighborhoodanalysis)
  4. [Cluster Neighborhoods](#clusterneighborhoods)
  5. [Examine Clusters](#clusters) 


* [Results and Discussion](#results) 
* [Conclusion](#conclusion)

### **Introduction** <a name="introduction"></a>

My project is about finding a proper way to buy a house in London.
Instead of just pick a nice one, I'd like to find the best one according to my preferences.
I am going to use Foresquare and clustering to solve the problem and get the neighborhood where I might to look around to live.

Also I have preferences, like
- least populated area where 
- the average price is lower then £350.000
- it should be safe for sure, and
- it would be just nice if the poeple around were not too old

So I have strict requests to find the neighborhood where I should start the search.

To solve the problem I would create a dataset which will contain useful information about London's districts and I will use this one to get data from Foursquare.

Those who wants to buy a new house might be interested on the method I applied here.


[back to the top](#top)

### **Data** <a name="data"></a>

#### Administraive areas

The table (requested from [https://www.doogal.co.uk/AdministrativeAreas.php](https://www.doogal.co.uk/AdministrativeAreas.php) ) conatains the postcode data filtered by administrative area that is Districts.
The dataset contain the codes of every districts and their geographical data i.e. Latitude and Longitude.

#### London postcodes

The table requested from [https://www.doogal.co.uk/london_postcodes.php](https://www.doogal.co.uk/london_postcodes.php) 

This is a complete list of London postcode districts with their Ordnance Survey coordinates and longitude and latitude.
It seems cool but notice the Latitude and Longitude data are go with the Postcode which is a bit deep level for this examination.

On the other hand it contains the data of **District Code**, **Ward Code**, **District**, **Ward**, **Rural/urban**.
Those data would be useful:
- District Code and the Ward Code for merging with other datasets,
- Rural/urban for the analysis

#### Ward level geographical data

The table requested from [http://geoportal.statistics.gov.uk/datasets/wards-december-2018-full-clipped-boundaries-gb/data](
http://geoportal.statistics.gov.uk/datasets/wards-december-2018-full-clipped-boundaries-gb/data) 

To get geographical data about wards. It does not contains ward level data so I could merge it with the *London postcodes* dataset

#### London borough profile

The table requested from [https://data.london.gov.uk/dataset/london-borough-profiles](
https://data.london.gov.uk/dataset/london-borough-profiles) 

Borough profile displays data for that borough, plus either Inner or Outer London, London and a national comparator (usually England where data is available). The data is set out across 11 themes covering most of the key indicators relating to demographic, economic, social and environmental data. 

I would mainly use **GLA Population Estimate 2017**, **GLA Household Estimate 2017**, 
**Population density (per hectare) 2017**, **Average Age, 2017** columns to help me to get closer to the desirable new House.

#### Recorded crime summary

The table requested from [https://data.london.gov.uk/dataset/recorded_crime_summary](https://data.london.gov.uk/dataset/recorded_crime_summary)

This data counts the number of crimes at three different geographic levels of London (borough, ward, LSOA) per month, according to crime type. 
I will not show all the data provided, because I will summarize them i.e. I need only one number per wards to help me compare the safety of wards

#### House Price Index - HPI

The table requested from [https://data.london.gov.uk/dataset/uk-house-price-index](https://data.london.gov.uk/dataset/uk-house-price-index)

The UK House Price Index (UK HPI) captures changes in the value of residential properties.

The UK HPI uses sales data collected on residential housing transactions, whether for cash or with a mortgage.

The **Average price** and the **Sales volume** are available from this table which I definiately need to solve the problem


[back to the top](#top)

---

#### Get the neighborhood

Once I collected all the needed data and created the dataset I want, I will start to examine it to find the proper neighborhood which is:
- least crowded, so least populated
- the average price is lower then £350.000
- safe
- the area is youthful

Once I get the neighborhood which is close enough to my expectation (filtered data) I will use the data to make a map and then to make clusters to see the venues.

Based on the filtered data and the venues I am going to have the idea where to start the searching.


[back to the top](#top)

### **Methodology** <a name="methodology"></a>

In this project I am going to make my effort to detecting the correspondent area of London with relatively low crime volume, populated mostly with youth and for sure with a convinient price. I am using Foursquare to find a family friendly **Ward** with regarding venues.

I will limit the analysis to area ~1km around the **Ward** I found.

In first step I have collected the required **data: Location data** (Postcodes, Latitude, Longitude), **Borough profile, Crime data** and **House Price Index**.

Get [Administrative areas](https://www.doogal.co.uk/AdministrativeAreas.php)

Since we need only three columns from it, I extract *District Code*, *Latitude*, *Longitude*
Also I rename those columns to show they belong to Districts


Get [London postcodes](https://www.doogal.co.uk/london_postcodes.php) then check the dataset

Create a shorter dataset by get just the relevant columns and roll them up, so I have only one row for each Ward


Get [Ward level geographical data](http://geoportal.statistics.gov.uk/datasets/wards-december-2018-full-clipped-boundaries-gb/data)

Since there are a lot of columns I do not need right now, I am going to keep only *wd18cd*, *lat*, *long* columns and rename them as *Ward Code*, *Ward Latitude* and *Ward Longitude*. *Ward Code* will be used as the key to merge with df_full dataset


Get [London borough profile](https://data.london.gov.uk/dataset/london-borough-profiles)

The data is on the 'Data' sheet in an excel file. Also, after an examination I realized I do not need all of the columns but just a few so I grab only those. The first row contains nothing so just skeep it.
I need to rename the *New code* column too, which is our *District Code*


Get [Recorded crime summary](https://data.london.gov.uk/dataset/recorded_crime_summary)

I will use only the data of year 2017 (it starts with 201702) to be consistent with the other data.
We have *WardCode* in there but after I tried it I realised it is not as good to use to merge as the column *Borough* so I keep that one.
Also I do not need to know this time what kind of crime has been commited so i just create a **Total** column for them.
To create the **Total** column I am using *.loc[]* and aggregate all the columns containing crime data.
The crime dataset did not contain any row on *City of London* so I got **NaN** for these rows.
I do not want to get rid of these rows so I decided to replace those **NaN**-s with the mean
Also I need each borough only once so I aggregate the rows as well.


Get [House Price Index](https://data.london.gov.uk/dataset/uk-house-price-index)

I will get the data in two steps:
- in the first step I will get the *average price* which is on the sheet Average price
- in the second step I get the *sales volume* from the Sales volume sheet

From those excel sheets I need only the **Districts**, their **Districts Code** and the close data of 2017 which is **2017-12-01**

Then transpose the dataset and rename the columns

---

After I got the data I merge all og them into a new dataframe called df_full. First I use df_london dataset as a basic so when I am using **pd.merge()** on them I connect the tables with a *left join*. 



In the second step I am filtering the dataframe  so I will find the **Ward** which attributes are close enough to my expectation.

In the third step I will use clustering technique to find differences among the Wards.
I will use those clusters to decide where should I start to explore the neighborhood personally.
I will present map of all such locations as well.


[back to the top](#top)

---
### **Analysis / Exploration** <a name="analysis"></a>

Okay, that was all the data I needed. I put together so let's check them out.

Let's start with the location of the **Wards**

Observe the tbale we got:


  1. GLA Population Estimate 2017
- as you can guess, Urban city is the most poplutaed one however surprise surprise, not the rural site is the least populated but, the conurbation


  2. Population density (per hectare) 2017
- That one is interesting: I expected the city to have the highest density on population but I was wrong. However the hamlets are the least crowded area


  3. Average Age, 2017
- Conurbation again. Those areas have the youth


  4. Crime volume in 2017 
- The most of the crimes are commited in the conurbation area. The presence of the police might have more patrol in the inner city or maybe the conurbation area is just too big to supervise


  5. AVG price on 2017-12-01 
- I assume that a lot of people move to conurbation recently. This can be the explanation of the high average price, also it can explain the density


  6. Sales volume on 2017-12-01
- Despite the comments above the conurbation has the least sales volume


There are a lot of questions above which are out of our topic now, because the history is not importnat right now, however it would worth a proper examination.

Now, let's focus on why we are here. 

Let's apply our requests on the dataset

#### Mapping London <a name="mappinglondon"></a>

I am using geopy library to get the latitude and longitude values of London.

In order to define an instance of the geocoder, I define a user_agent. I will name our agent <em>UK_explorer</em>, as shown below.


```python
# create map of London using latitude and longitude values
map_london = folium.Map(location=[latitude, longitude], zoom_start=11)

# add markers to map
for lat, lng, district, ward in zip(df_tomap['Ward Latitude'], df_tomap['Ward Longitude'], df_tomap['District'], df_tomap['Ward']):
    label = '{}, {}'.format(district, ward)
    label = folium.Popup(label, parse_html=True)
    folium.CircleMarker(
        [lat, lng],
        radius=5,
        popup=label,
        color='blue',
        fill=True,
        fill_color='#3186cc',
        fill_opacity=0.7,
        parse_html=False).add_to(map_london)  
    
map_london
```




<div style="width:100%;"><div style="position:relative;width:100%;height:0;padding-bottom:60%;"><iframe src="data:text/html;charset=utf-8;base64,PCFET0NUWVBFIGh0bWw+CjxoZWFkPiAgICAKICAgIDxtZXRhIGh0dHAtZXF1aXY9ImNvbnRlbnQtdHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04IiAvPgogICAgPHNjcmlwdD5MX1BSRUZFUl9DQU5WQVMgPSBmYWxzZTsgTF9OT19UT1VDSCA9IGZhbHNlOyBMX0RJU0FCTEVfM0QgPSBmYWxzZTs8L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2FqYXguZ29vZ2xlYXBpcy5jb20vYWpheC9saWJzL2pxdWVyeS8xLjExLjEvanF1ZXJ5Lm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvanMvYm9vdHN0cmFwLm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvTGVhZmxldC5hd2Vzb21lLW1hcmtlcnMvMi4wLjIvbGVhZmxldC5hd2Vzb21lLW1hcmtlcnMuanMiPjwvc2NyaXB0PgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNi4zL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9MZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy8yLjAuMi9sZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9yYXdnaXQuY29tL3B5dGhvbi12aXN1YWxpemF0aW9uL2ZvbGl1bS9tYXN0ZXIvZm9saXVtL3RlbXBsYXRlcy9sZWFmbGV0LmF3ZXNvbWUucm90YXRlLmNzcyIvPgogICAgPHN0eWxlPmh0bWwsIGJvZHkge3dpZHRoOiAxMDAlO2hlaWdodDogMTAwJTttYXJnaW46IDA7cGFkZGluZzogMDt9PC9zdHlsZT4KICAgIDxzdHlsZT4jbWFwIHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDowO2xlZnQ6MDt9PC9zdHlsZT4KICAgIAogICAgICAgICAgICA8c3R5bGU+ICNtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEgewogICAgICAgICAgICAgICAgcG9zaXRpb24gOiByZWxhdGl2ZTsKICAgICAgICAgICAgICAgIHdpZHRoIDogMTAwLjAlOwogICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAuMCU7CiAgICAgICAgICAgICAgICBsZWZ0OiAwLjAlOwogICAgICAgICAgICAgICAgdG9wOiAwLjAlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICA8L3N0eWxlPgogICAgICAgIAo8L2hlYWQ+Cjxib2R5PiAgICAKICAgIAogICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb2xpdW0tbWFwIiBpZD0ibWFwXzVlZmRmMzE5MzNlMDQ4Yjc5NDQzNzU3NDAwZjRjZDAxIiA+PC9kaXY+CiAgICAgICAgCjwvYm9keT4KPHNjcmlwdD4gICAgCiAgICAKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG51bGw7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSA9IEwubWFwKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2VudGVyOiBbNTEuNTA3MzIxOSwtMC4xMjc2NDc0XSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb206IDExLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4Qm91bmRzOiBib3VuZHMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcnM6IFtdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRDb3B5SnVtcDogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnM6IEwuQ1JTLkVQU0czODU3CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgdGlsZV9sYXllcl82MzM0ZmJhZWVlNzk0Y2E4OWI0MWVlYjBjYzllMGY0NCA9IEwudGlsZUxheWVyKAogICAgICAgICAgICAgICAgJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJywKICAgICAgICAgICAgICAgIHsKICAiYXR0cmlidXRpb24iOiBudWxsLAogICJkZXRlY3RSZXRpbmEiOiBmYWxzZSwKICAibWF4Wm9vbSI6IDE4LAogICJtaW5ab29tIjogMSwKICAibm9XcmFwIjogZmFsc2UsCiAgInN1YmRvbWFpbnMiOiAiYWJjIgp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjk1YTRhZmQ0NmQ2NGU2MTg2MDE2YjI0YTcyNjNlOTggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41Mzk4MjE5OTk5OTk5OTQsMC4wODEyOTFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiYmx1ZSIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMzMTg2Y2MiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZTQzMTU0ZTU1Mzk5NDhlOWI4NjM4NTk2M2QxMzU3MWYgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfYmRmMzUzMzlkMjhmNDU0YzhmYWQ0ZjU0M2FiZmU2M2YgPSAkKCc8ZGl2IGlkPSJodG1sX2JkZjM1MzM5ZDI4ZjQ1NGM4ZmFkNGY1NDNhYmZlNjNmIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5CYXJraW5nIGFuZCBEYWdlbmhhbSwgQWJiZXk8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2U0MzE1NGU1NTM5OTQ4ZTliODYzODU5NjNkMTM1NzFmLnNldENvbnRlbnQoaHRtbF9iZGYzNTMzOWQyOGY0NTRjOGZhZDRmNTQzYWJmZTYzZik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9mOTVhNGFmZDQ2ZDY0ZTYxODYwMTZiMjRhNzI2M2U5OC5iaW5kUG9wdXAocG9wdXBfZTQzMTU0ZTU1Mzk5NDhlOWI4NjM4NTk2M2QxMzU3MWYpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNjA2NTE0ZDBjMmVhNGU2NjkyZmU0MzkwZGZmM2UzYTIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NDU5MjEsMC4xNTA5ODY5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJibHVlIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzMxODZjYyIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF80MDUxZDNmNjk4ODQ0NzIwODA0YWY0YmFmNWM0OTA4MSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF85MDFjN2E4MjY0YjY0YjUxODA1YTcyZjc1NjQ5MWUyZCA9ICQoJzxkaXYgaWQ9Imh0bWxfOTAxYzdhODI2NGI2NGI1MTgwNWE3MmY3NTY0OTFlMmQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJhcmtpbmcgYW5kIERhZ2VuaGFtLCBBbGlib248L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzQwNTFkM2Y2OTg4NDQ3MjA4MDRhZjRiYWY1YzQ5MDgxLnNldENvbnRlbnQoaHRtbF85MDFjN2E4MjY0YjY0YjUxODA1YTcyZjc1NjQ5MWUyZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl82MDY1MTRkMGMyZWE0ZTY2OTJmZTQzOTBkZmYzZTNhMi5iaW5kUG9wdXAocG9wdXBfNDA1MWQzZjY5ODg0NDcyMDgwNGFmNGJhZjVjNDkwODEpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZjNhY2Q0ZGEwODdkNGMyOTg3MTdlNzFiNzZmYmE1YzMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NTI2MDEsMC4xMTY5MTE5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJibHVlIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzMxODZjYyIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF83NTJiYTY5MjVkZmI0NGE5Yjc1ZDhlZWZkZGE1ZTQ1ZSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF85NmJlNTM0YTExMTk0NTdlYWI0NGEwOTIyOGNmNTc2ZCA9ICQoJzxkaXYgaWQ9Imh0bWxfOTZiZTUzNGExMTE5NDU3ZWFiNDRhMDkyMjhjZjU3NmQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJhcmtpbmcgYW5kIERhZ2VuaGFtLCBCZWNvbnRyZWU8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzc1MmJhNjkyNWRmYjQ0YTliNzVkOGVlZmRkYTVlNDVlLnNldENvbnRlbnQoaHRtbF85NmJlNTM0YTExMTk0NTdlYWI0NGEwOTIyOGNmNTc2ZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9mM2FjZDRkYTA4N2Q0YzI5ODcxN2U3MWI3NmZiYTVjMy5iaW5kUG9wdXAocG9wdXBfNzUyYmE2OTI1ZGZiNDRhOWI3NWQ4ZWVmZGRhNWU0NWUpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfY2JlZTYxYjllNDQ5NDI2ODg1NWY3MmM0YjliMmZlYTkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41ODM0MjAwMDAwMDAwMDQsMC4xMzg1OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiYmx1ZSIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMzMTg2Y2MiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZDM1Mjk4M2ZmOGU4NDgxMTlmZTQyN2YxNmJjZDVhNjMgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMmM2ZTZkZmFlOGVmNGNiYmExNjcyZDhiNjJmNDBkMTEgPSAkKCc8ZGl2IGlkPSJodG1sXzJjNmU2ZGZhZThlZjRjYmJhMTY3MmQ4YjYyZjQwZDExIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5CYXJraW5nIGFuZCBEYWdlbmhhbSwgQ2hhZHdlbGwgSGVhdGg8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2QzNTI5ODNmZjhlODQ4MTE5ZmU0MjdmMTZiY2Q1YTYzLnNldENvbnRlbnQoaHRtbF8yYzZlNmRmYWU4ZWY0Y2JiYTE2NzJkOGI2MmY0MGQxMSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9jYmVlNjFiOWU0NDk0MjY4ODU1ZjcyYzRiOWIyZmVhOS5iaW5kUG9wdXAocG9wdXBfZDM1Mjk4M2ZmOGU4NDgxMTlmZTQyN2YxNmJjZDVhNjMpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMzI1OTBlMWMwZWJiNGIzZGE1NWQxYzc0YjUzYzgzYzUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NTUxOTEsMC4xNzM0NTNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiYmx1ZSIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMzMTg2Y2MiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMmUwYjkyOTM3MDA2NDc5ZjliOTc4OGNkZmQ0YjYyMzIgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZTg0YmJiZGE2NGNiNDAzMGIzMTgwYjI2MjQ2ZDhhZDMgPSAkKCc8ZGl2IGlkPSJodG1sX2U4NGJiYmRhNjRjYjQwMzBiMzE4MGIyNjI0NmQ4YWQzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5CYXJraW5nIGFuZCBEYWdlbmhhbSwgRWFzdGJyb29rPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8yZTBiOTI5MzcwMDY0NzlmOWI5Nzg4Y2RmZDRiNjIzMi5zZXRDb250ZW50KGh0bWxfZTg0YmJiZGE2NGNiNDAzMGIzMTgwYjI2MjQ2ZDhhZDMpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfMzI1OTBlMWMwZWJiNGIzZGE1NWQxYzc0YjUzYzgzYzUuYmluZFBvcHVwKHBvcHVwXzJlMGI5MjkzNzAwNjQ3OWY5Yjk3ODhjZGZkNGI2MjMyKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2M0M2E2NzY5MmY2MjRjZjFiZTdjMjE2OWJiYzhlMDdkID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTM1ODA5LDAuMTA0NzU1OTk5OTk5OTk5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiYmx1ZSIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMzMTg2Y2MiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMjQ5ODg1ZDQzZTFjNDM5YTgzMDgxYTIzNzYwMjBhMDcgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNjc0ZDczMDEwZmMzNGI0Y2IzNmI0ZTM2YzY2NjMyMzAgPSAkKCc8ZGl2IGlkPSJodG1sXzY3NGQ3MzAxMGZjMzRiNGNiMzZiNGUzNmM2NjYzMjMwIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5CYXJraW5nIGFuZCBEYWdlbmhhbSwgRWFzdGJ1cnk8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzI0OTg4NWQ0M2UxYzQzOWE4MzA4MWEyMzc2MDIwYTA3LnNldENvbnRlbnQoaHRtbF82NzRkNzMwMTBmYzM0YjRjYjM2YjRlMzZjNjY2MzIzMCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9jNDNhNjc2OTJmNjI0Y2YxYmU3YzIxNjliYmM4ZTA3ZC5iaW5kUG9wdXAocG9wdXBfMjQ5ODg1ZDQzZTFjNDM5YTgzMDgxYTIzNzYwMjBhMDcpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfOGNlMGIxYTRjNzY3NGZkZjhkNWE4MmYzZDlhNDk5MzggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MzI1ODEsMC4wODU3MDRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiYmx1ZSIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMzMTg2Y2MiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMzcwZGNhOWE0ODViNDUxZGEyODc2MmE3NzNhZjc4ZTEgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZWE4MzA4NDE3MDY5NDRjNmE1ZWJkYzQwY2E5MmIzYTMgPSAkKCc8ZGl2IGlkPSJodG1sX2VhODMwODQxNzA2OTQ0YzZhNWViZGM0MGNhOTJiM2EzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5CYXJraW5nIGFuZCBEYWdlbmhhbSwgR2FzY29pZ25lPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8zNzBkY2E5YTQ4NWI0NTFkYTI4NzYyYTc3M2FmNzhlMS5zZXRDb250ZW50KGh0bWxfZWE4MzA4NDE3MDY5NDRjNmE1ZWJkYzQwY2E5MmIzYTMpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfOGNlMGIxYTRjNzY3NGZkZjhkNWE4MmYzZDlhNDk5MzguYmluZFBvcHVwKHBvcHVwXzM3MGRjYTlhNDg1YjQ1MWRhMjg3NjJhNzczYWY3OGUxKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2UxMTU3ZmY3MTYwMzRlYjRhNDY1MWIyYWVjYzRkNGYzID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTM2MDQxLDAuMTMyNjQxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogImJsdWUiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICIjMzE4NmNjIiwKICAiZmlsbE9wYWNpdHkiOiAwLjcsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMS4wLAogICJyYWRpdXMiOiA1LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzVlZmRmMzE5MzNlMDQ4Yjc5NDQzNzU3NDAwZjRjZDAxKTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2ZjZTEyMjlkYTAyMDQxMDE5ZTYxY2VhNzIyMTZiNWFjID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2RmMjRiN2U5NjU3ZDQxMTJiMTE5NThiYzg0MDMxNDMwID0gJCgnPGRpdiBpZD0iaHRtbF9kZjI0YjdlOTY1N2Q0MTEyYjExOTU4YmM4NDAzMTQzMCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+QmFya2luZyBhbmQgRGFnZW5oYW0sIEdvcmVzYnJvb2s8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2ZjZTEyMjlkYTAyMDQxMDE5ZTYxY2VhNzIyMTZiNWFjLnNldENvbnRlbnQoaHRtbF9kZjI0YjdlOTY1N2Q0MTEyYjExOTU4YmM4NDAzMTQzMCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9lMTE1N2ZmNzE2MDM0ZWI0YTQ2NTFiMmFlY2M0ZDRmMy5iaW5kUG9wdXAocG9wdXBfZmNlMTIyOWRhMDIwNDEwMTllNjFjZWE3MjIxNmI1YWMpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDU4YTViYWNkZmE3NDJjOWJlZmE1ZWU4MjI1YWQ4ZTQgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NTg2ODksMC4xNTI5MzA5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJibHVlIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzMxODZjYyIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9kZDNlZGRjMGRjMWI0NTJlOWNkMzBiN2IzMmM1YTFjMCA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9lN2UwYjY0MzQ2OTY0MGIyOGIzNDBhM2NmZTgxZGE1NCA9ICQoJzxkaXYgaWQ9Imh0bWxfZTdlMGI2NDM0Njk2NDBiMjhiMzQwYTNjZmU4MWRhNTQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJhcmtpbmcgYW5kIERhZ2VuaGFtLCBIZWF0aDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfZGQzZWRkYzBkYzFiNDUyZTljZDMwYjdiMzJjNWExYzAuc2V0Q29udGVudChodG1sX2U3ZTBiNjQzNDY5NjQwYjI4YjM0MGEzY2ZlODFkYTU0KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzA1OGE1YmFjZGZhNzQyYzliZWZhNWVlODIyNWFkOGU0LmJpbmRQb3B1cChwb3B1cF9kZDNlZGRjMGRjMWI0NTJlOWNkMzBiN2IzMmM1YTFjMCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9jZGExNTUzZWZkOGY0ODAyOWQxOTc1NmM5MGQ5MWZiZCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjU0NDQzLDAuMDkzNjQ0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogImJsdWUiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICIjMzE4NmNjIiwKICAiZmlsbE9wYWNpdHkiOiAwLjcsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMS4wLAogICJyYWRpdXMiOiA1LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzVlZmRmMzE5MzNlMDQ4Yjc5NDQzNzU3NDAwZjRjZDAxKTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2ZiYThkNDBiYzZlNzQ5OGE4ZDVkZjZiZTY4ODFjZmVhID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzk5MjdkYzI3ZjljMTRjNjA4MTFmZGU0M2I1NWQ4ZDUxID0gJCgnPGRpdiBpZD0iaHRtbF85OTI3ZGMyN2Y5YzE0YzYwODExZmRlNDNiNTVkOGQ1MSIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+QmFya2luZyBhbmQgRGFnZW5oYW0sIExvbmdicmlkZ2U8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2ZiYThkNDBiYzZlNzQ5OGE4ZDVkZjZiZTY4ODFjZmVhLnNldENvbnRlbnQoaHRtbF85OTI3ZGMyN2Y5YzE0YzYwODExZmRlNDNiNTVkOGQ1MSk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9jZGExNTUzZWZkOGY0ODAyOWQxOTc1NmM5MGQ5MWZiZC5iaW5kUG9wdXAocG9wdXBfZmJhOGQ0MGJjNmU3NDk4YThkNWRmNmJlNjg4MWNmZWEpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDFjNTgzOTBkNWEzNDdiNGFlMDdlNmNkNTRiY2Y1ODkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NDUxODksMC4xMjAzMzJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiYmx1ZSIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMzMTg2Y2MiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZWRiMDk5MzU4Njg5NGU2N2I0NTUzM2E2NGUxNDVhNzEgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMjZhMjBkY2M3NTliNDdlMWJiMDY0ZGRlZTY5MDE4N2YgPSAkKCc8ZGl2IGlkPSJodG1sXzI2YTIwZGNjNzU5YjQ3ZTFiYjA2NGRkZWU2OTAxODdmIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5CYXJraW5nIGFuZCBEYWdlbmhhbSwgTWF5ZXNicm9vazwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfZWRiMDk5MzU4Njg5NGU2N2I0NTUzM2E2NGUxNDVhNzEuc2V0Q29udGVudChodG1sXzI2YTIwZGNjNzU5YjQ3ZTFiYjA2NGRkZWU2OTAxODdmKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzAxYzU4MzkwZDVhMzQ3YjRhZTA3ZTZjZDU0YmNmNTg5LmJpbmRQb3B1cChwb3B1cF9lZGIwOTkzNTg2ODk0ZTY3YjQ1NTMzYTY0ZTE0NWE3MSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9lMDI2MGQzODZlNDE0MzBhOTM5NzY1ZGY4ZjdkMTljNiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjU0OTgzMSwwLjEzNTM0OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJibHVlIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzMxODZjYyIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF83NzVkOTIwNjRjOGU0OTc1OGQ3OTA5NTJkZDU5NTU3MSA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF84MzFhZTQ0YzQ1YmE0MGYwOTc4MGJjYTA4YjU0ZTFmZCA9ICQoJzxkaXYgaWQ9Imh0bWxfODMxYWU0NGM0NWJhNDBmMDk3ODBiY2EwOGI1NGUxZmQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJhcmtpbmcgYW5kIERhZ2VuaGFtLCBQYXJzbG9lczwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNzc1ZDkyMDY0YzhlNDk3NThkNzkwOTUyZGQ1OTU1NzEuc2V0Q29udGVudChodG1sXzgzMWFlNDRjNDViYTQwZjA5NzgwYmNhMDhiNTRlMWZkKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2UwMjYwZDM4NmU0MTQzMGE5Mzk3NjVkZjhmN2QxOWM2LmJpbmRQb3B1cChwb3B1cF83NzVkOTIwNjRjOGU0OTc1OGQ3OTA5NTJkZDU5NTU3MSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zYmY3YzNkM2E1MmQ0MTFlYTFmNjliMTJiNmUwYzRkYiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUyNDUwMjAwMDAwMDAwNSwwLjE1MjY0NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJibHVlIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzMxODZjYyIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF84YTM0ZDg1Nzg2YmI0Y2Q1ODg4OTNkYmYxMGIxY2MxZiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8xZTA2YzU0NzM3YzQ0NGQwYWQwMWE1YjU3OTQ3NzU3MyA9ICQoJzxkaXYgaWQ9Imh0bWxfMWUwNmM1NDczN2M0NDRkMGFkMDFhNWI1Nzk0Nzc1NzMiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJhcmtpbmcgYW5kIERhZ2VuaGFtLCBSaXZlcjwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfOGEzNGQ4NTc4NmJiNGNkNTg4ODkzZGJmMTBiMWNjMWYuc2V0Q29udGVudChodG1sXzFlMDZjNTQ3MzdjNDQ0ZDBhZDAxYTViNTc5NDc3NTczKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzNiZjdjM2QzYTUyZDQxMWVhMWY2OWIxMmI2ZTBjNGRiLmJpbmRQb3B1cChwb3B1cF84YTM0ZDg1Nzg2YmI0Y2Q1ODg4OTNkYmYxMGIxY2MxZik7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83MzhjMzRiNWI5ZWM0ZWI0YTE5MWZiYTBhNjhmNmExZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUyNDA3OCwwLjExOTc0Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJibHVlIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzMxODZjYyIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9lYzEzYmNlMjgyZjI0OTQzOTY1MTY5ZWE1YmI3ODExNCA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF83Njc5MTZhNDg4ZDY0MmJlYjRiYTU3YjlkMjliNjhkYyA9ICQoJzxkaXYgaWQ9Imh0bWxfNzY3OTE2YTQ4OGQ2NDJiZWI0YmE1N2I5ZDI5YjY4ZGMiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJhcmtpbmcgYW5kIERhZ2VuaGFtLCBUaGFtZXM8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2VjMTNiY2UyODJmMjQ5NDM5NjUxNjllYTViYjc4MTE0LnNldENvbnRlbnQoaHRtbF83Njc5MTZhNDg4ZDY0MmJlYjRiYTU3YjlkMjliNjhkYyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl83MzhjMzRiNWI5ZWM0ZWI0YTE5MWZiYTBhNjhmNmExZi5iaW5kUG9wdXAocG9wdXBfZWMxM2JjZTI4MmYyNDk0Mzk2NTE2OWVhNWJiNzgxMTQpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfM2NmNjhkZjI0ZTYxNDZiOWJmZTA0Nzc2ZTY2NGU2NmUgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NjEyMywwLjEzNTkyNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICJibHVlIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzMxODZjYyIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF81ZWZkZjMxOTMzZTA0OGI3OTQ0Mzc1NzQwMGY0Y2QwMSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8zYWIzZjJmZGU5NTA0OTI2YWQ5YTU3ZDQ4NzViNGZlMyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9iYTBiYzQzNDQ2ZmI0NjcxODZlNzk5YjAxMmUzNjQ1OSA9ICQoJzxkaXYgaWQ9Imh0bWxfYmEwYmM0MzQ0NmZiNDY3MTg2ZTc5OWIwMTJlMzY0NTkiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJhcmtpbmcgYW5kIERhZ2VuaGFtLCBWYWxlbmNlPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8zYWIzZjJmZGU5NTA0OTI2YWQ5YTU3ZDQ4NzViNGZlMy5zZXRDb250ZW50KGh0bWxfYmEwYmM0MzQ0NmZiNDY3MTg2ZTc5OWIwMTJlMzY0NTkpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfM2NmNjhkZjI0ZTYxNDZiOWJmZTA0Nzc2ZTY2NGU2NmUuYmluZFBvcHVwKHBvcHVwXzNhYjNmMmZkZTk1MDQ5MjZhZDlhNTdkNDg3NWI0ZmUzKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2RhZTk3ZDk0NDdmOTRhMWJiNzJhMTFhMjVkYzAyYzY4ID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTM2NTkwOTk5OTk5OTk0LDAuMTY2NjEwOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiYmx1ZSIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMzMTg2Y2MiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNWVmZGYzMTkzM2UwNDhiNzk0NDM3NTc0MDBmNGNkMDEpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMmUzZGZmY2U3ODc5NGE2NWIyNDQwNjM4NDVjYTZmMTUgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMWUzN2RmY2Q5MzQzNDg1YWJmMjkwY2ExNTI5MGVmODcgPSAkKCc8ZGl2IGlkPSJodG1sXzFlMzdkZmNkOTM0MzQ4NWFiZjI5MGNhMTUyOTBlZjg3IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5CYXJraW5nIGFuZCBEYWdlbmhhbSwgVmlsbGFnZTwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfMmUzZGZmY2U3ODc5NGE2NWIyNDQwNjM4NDVjYTZmMTUuc2V0Q29udGVudChodG1sXzFlMzdkZmNkOTM0MzQ4NWFiZjI5MGNhMTUyOTBlZjg3KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2RhZTk3ZDk0NDdmOTRhMWJiNzJhMTFhMjVkYzAyYzY4LmJpbmRQb3B1cChwb3B1cF8yZTNkZmZjZTc4Nzk0YTY1YjI0NDA2Mzg0NWNhNmYxNSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83MDE1ZjhmZDdmYTc0MTg0YjZkZWY4OGM1NTMxMDhiYyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjU2ODI3MiwwLjE0MTkxMDk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogImJsdWUiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICIjMzE4NmNjIiwKICAiZmlsbE9wYWNpdHkiOiAwLjcsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMS4wLAogICJyYWRpdXMiOiA1LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzVlZmRmMzE5MzNlMDQ4Yjc5NDQzNzU3NDAwZjRjZDAxKTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzEzOTg0NTFhMTIyZjRiMDliNWNkMGRmNTg5MWU3NTMzID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzZkODUyNmNkYWY4MDQ5NjliYTljNGUwYjA2MDBiMTIzID0gJCgnPGRpdiBpZD0iaHRtbF82ZDg1MjZjZGFmODA0OTY5YmE5YzRlMGIwNjAwYjEyMyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+QmFya2luZyBhbmQgRGFnZW5oYW0sIFdoYWxlYm9uZTwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfMTM5ODQ1MWExMjJmNGIwOWI1Y2QwZGY1ODkxZTc1MzMuc2V0Q29udGVudChodG1sXzZkODUyNmNkYWY4MDQ5NjliYTljNGUwYjA2MDBiMTIzKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzcwMTVmOGZkN2ZhNzQxODRiNmRlZjg4YzU1MzEwOGJjLmJpbmRQb3B1cChwb3B1cF8xMzk4NDUxYTEyMmY0YjA5YjVjZDBkZjU4OTFlNzUzMyk7CgogICAgICAgICAgICAKICAgICAgICAKPC9zY3JpcHQ+" style="position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div></div>



Also I visualize the resulting clusters


```python
# Matplotlib and associated plotting modules
import matplotlib.cm as cm
import matplotlib.colors as colors

# create map
map_clusters = folium.Map(location=[latitude, longitude], zoom_start=11)

# set color scheme for the clusters
x = np.arange(kclusters)
ys = [i + x + (i*x)**2 for i in range(kclusters)]
colors_array = cm.rainbow(np.linspace(0, 1, len(ys)))
rainbow = [colors.rgb2hex(i) for i in colors_array]

# add markers to the map
markers_colors = []
for lat, lon, poi, cluster in zip(london_merged['Ward Latitude'], london_merged['Ward Longitude'], 
                                  london_merged['Neighborhood'], london_merged['Cluster Labels']):
    label = folium.Popup(str(poi) + ' Cluster ' + str(cluster), parse_html=True)
    folium.CircleMarker(
        [lat, lon],
        radius=5,
        popup=label,
        color=rainbow[cluster-1],
        fill=True,
        fill_color=rainbow[cluster-1],
        fill_opacity=0.7).add_to(map_clusters)
       
map_clusters
```




<div style="width:100%;"><div style="position:relative;width:100%;height:0;padding-bottom:60%;"><iframe src="data:text/html;charset=utf-8;base64,PCFET0NUWVBFIGh0bWw+CjxoZWFkPiAgICAKICAgIDxtZXRhIGh0dHAtZXF1aXY9ImNvbnRlbnQtdHlwZSIgY29udGVudD0idGV4dC9odG1sOyBjaGFyc2V0PVVURi04IiAvPgogICAgPHNjcmlwdD5MX1BSRUZFUl9DQU5WQVMgPSBmYWxzZTsgTF9OT19UT1VDSCA9IGZhbHNlOyBMX0RJU0FCTEVfM0QgPSBmYWxzZTs8L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmpzIj48L3NjcmlwdD4KICAgIDxzY3JpcHQgc3JjPSJodHRwczovL2FqYXguZ29vZ2xlYXBpcy5jb20vYWpheC9saWJzL2pxdWVyeS8xLjExLjEvanF1ZXJ5Lm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvanMvYm9vdHN0cmFwLm1pbi5qcyI+PC9zY3JpcHQ+CiAgICA8c2NyaXB0IHNyYz0iaHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvTGVhZmxldC5hd2Vzb21lLW1hcmtlcnMvMi4wLjIvbGVhZmxldC5hd2Vzb21lLW1hcmtlcnMuanMiPjwvc2NyaXB0PgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2xlYWZsZXRAMS4yLjAvZGlzdC9sZWFmbGV0LmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL21heGNkbi5ib290c3RyYXBjZG4uY29tL2Jvb3RzdHJhcC8zLjIuMC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9tYXhjZG4uYm9vdHN0cmFwY2RuLmNvbS9ib290c3RyYXAvMy4yLjAvY3NzL2Jvb3RzdHJhcC10aGVtZS5taW4uY3NzIi8+CiAgICA8bGluayByZWw9InN0eWxlc2hlZXQiIGhyZWY9Imh0dHBzOi8vbWF4Y2RuLmJvb3RzdHJhcGNkbi5jb20vZm9udC1hd2Vzb21lLzQuNi4zL2Nzcy9mb250LWF3ZXNvbWUubWluLmNzcyIvPgogICAgPGxpbmsgcmVsPSJzdHlsZXNoZWV0IiBocmVmPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9MZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy8yLjAuMi9sZWFmbGV0LmF3ZXNvbWUtbWFya2Vycy5jc3MiLz4KICAgIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iaHR0cHM6Ly9yYXdnaXQuY29tL3B5dGhvbi12aXN1YWxpemF0aW9uL2ZvbGl1bS9tYXN0ZXIvZm9saXVtL3RlbXBsYXRlcy9sZWFmbGV0LmF3ZXNvbWUucm90YXRlLmNzcyIvPgogICAgPHN0eWxlPmh0bWwsIGJvZHkge3dpZHRoOiAxMDAlO2hlaWdodDogMTAwJTttYXJnaW46IDA7cGFkZGluZzogMDt9PC9zdHlsZT4KICAgIDxzdHlsZT4jbWFwIHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDowO2xlZnQ6MDt9PC9zdHlsZT4KICAgIAogICAgICAgICAgICA8c3R5bGU+ICNtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUgewogICAgICAgICAgICAgICAgcG9zaXRpb24gOiByZWxhdGl2ZTsKICAgICAgICAgICAgICAgIHdpZHRoIDogMTAwLjAlOwogICAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAuMCU7CiAgICAgICAgICAgICAgICBsZWZ0OiAwLjAlOwogICAgICAgICAgICAgICAgdG9wOiAwLjAlOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICA8L3N0eWxlPgogICAgICAgIAo8L2hlYWQ+Cjxib2R5PiAgICAKICAgIAogICAgICAgICAgICA8ZGl2IGNsYXNzPSJmb2xpdW0tbWFwIiBpZD0ibWFwXzc2NjNjNDJlNTMyZjRiYzY4NThjMDM4MTE4Y2I0NGU1IiA+PC9kaXY+CiAgICAgICAgCjwvYm9keT4KPHNjcmlwdD4gICAgCiAgICAKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG51bGw7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgdmFyIG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSA9IEwubWFwKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2VudGVyOiBbNTEuNTA3MzIxOSwtMC4xMjc2NDc0XSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb206IDExLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4Qm91bmRzOiBib3VuZHMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcnM6IFtdLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRDb3B5SnVtcDogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnM6IEwuQ1JTLkVQU0czODU3CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgdGlsZV9sYXllcl9hYTJkMDI0ZThiYjY0YTM1YTRmYzk0ZWM4YzNmNDRmMiA9IEwudGlsZUxheWVyKAogICAgICAgICAgICAgICAgJ2h0dHBzOi8ve3N9LnRpbGUub3BlbnN0cmVldG1hcC5vcmcve3p9L3t4fS97eX0ucG5nJywKICAgICAgICAgICAgICAgIHsKICAiYXR0cmlidXRpb24iOiBudWxsLAogICJkZXRlY3RSZXRpbmEiOiBmYWxzZSwKICAibWF4Wm9vbSI6IDE4LAogICJtaW5ab29tIjogMSwKICAibm9XcmFwIjogZmFsc2UsCiAgInN1YmRvbWFpbnMiOiAiYWJjIgp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTkxNDM3ZTllYWJlNGM4NDhjMmZmNThkNTBiNDM3YzMgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41Mzk4MjE5OTk5OTk5OTQsMC4wODEyOTFdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiIzAwYjVlYiIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMwMGI1ZWIiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZWQ3YWFhNmE4YTNjNDQzOThhZTkxY2I5Mzc5MzgzNmEgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfZGJlNGJmMWI5NjJhNDBiNWJhYTVhZDc2Nzg5ZTQ3MTggPSAkKCc8ZGl2IGlkPSJodG1sX2RiZTRiZjFiOTYyYTQwYjViYWE1YWQ3Njc4OWU0NzE4IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5BYmJleSBDbHVzdGVyIDI8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2VkN2FhYTZhOGEzYzQ0Mzk4YWU5MWNiOTM3OTM4MzZhLnNldENvbnRlbnQoaHRtbF9kYmU0YmYxYjk2MmE0MGI1YmFhNWFkNzY3ODllNDcxOCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8xOTE0MzdlOWVhYmU0Yzg0OGMyZmY1OGQ1MGI0MzdjMy5iaW5kUG9wdXAocG9wdXBfZWQ3YWFhNmE4YTNjNDQzOThhZTkxY2I5Mzc5MzgzNmEpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMDJkNDE2ZjI3YTI2NDgzMDk0ZmRkOWQ4YWNmNzViYzggPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NDU5MjEsMC4xNTA5ODY5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICIjMDBiNWViIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzAwYjVlYiIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8yOTBiYTliY2NlYmM0YmExYjMzZjM0NGQ3MWY5YTI3MyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9jNTcwN2YwMDhjMmQ0ZGEyOGQyZTdhZTVkMWI0MTliMCA9ICQoJzxkaXYgaWQ9Imh0bWxfYzU3MDdmMDA4YzJkNGRhMjhkMmU3YWU1ZDFiNDE5YjAiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkFsaWJvbiBDbHVzdGVyIDI8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzI5MGJhOWJjY2ViYzRiYTFiMzNmMzQ0ZDcxZjlhMjczLnNldENvbnRlbnQoaHRtbF9jNTcwN2YwMDhjMmQ0ZGEyOGQyZTdhZTVkMWI0MTliMCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8wMmQ0MTZmMjdhMjY0ODMwOTRmZGQ5ZDhhY2Y3NWJjOC5iaW5kUG9wdXAocG9wdXBfMjkwYmE5YmNjZWJjNGJhMWIzM2YzNDRkNzFmOWEyNzMpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYTcyYTcwMWIzZGM3NDRiOGE4M2NhZThiNGI1OThhZGEgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NTI2MDEsMC4xMTY5MTE5OTk5OTk5OTk5OV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICIjMDBiNWViIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzAwYjVlYiIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF8wODc5ZWViNGE0ZDk0NjY0Yjg0NzhlZjk2NDQxY2JjYyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8yNmUwZDYzZGQ5MzY0ZDFjYTFkZTE5YWJmMjJmMzQ1MiA9ICQoJzxkaXYgaWQ9Imh0bWxfMjZlMGQ2M2RkOTM2NGQxY2ExZGUxOWFiZjIyZjM0NTIiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkJlY29udHJlZSBDbHVzdGVyIDI8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzA4NzllZWI0YTRkOTQ2NjRiODQ3OGVmOTY0NDFjYmNjLnNldENvbnRlbnQoaHRtbF8yNmUwZDYzZGQ5MzY0ZDFjYTFkZTE5YWJmMjJmMzQ1Mik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9hNzJhNzAxYjNkYzc0NGI4YTgzY2FlOGI0YjU5OGFkYS5iaW5kUG9wdXAocG9wdXBfMDg3OWVlYjRhNGQ5NDY2NGI4NDc4ZWY5NjQ0MWNiY2MpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNzA5MjY4M2I4ODUzNDk0NjhiYzY4YmU4N2JiNzgxNTIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41ODM0MjAwMDAwMDAwMDQsMC4xMzg1OTZdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiIzAwYjVlYiIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiMwMGI1ZWIiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZTNiNmU2NTg0OWUyNDU5MDliM2NmMjFmNzFjMDY3YjYgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfOTI5NTNkMGQ1NDUzNDk1NDg5NTg2NWJkMDViMDlhZWQgPSAkKCc8ZGl2IGlkPSJodG1sXzkyOTUzZDBkNTQ1MzQ5NTQ4OTU4NjViZDA1YjA5YWVkIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5DaGFkd2VsbCBIZWF0aCBDbHVzdGVyIDI8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2UzYjZlNjU4NDllMjQ1OTA5YjNjZjIxZjcxYzA2N2I2LnNldENvbnRlbnQoaHRtbF85Mjk1M2QwZDU0NTM0OTU0ODk1ODY1YmQwNWIwOWFlZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl83MDkyNjgzYjg4NTM0OTQ2OGJjNjhiZTg3YmI3ODE1Mi5iaW5kUG9wdXAocG9wdXBfZTNiNmU2NTg0OWUyNDU5MDliM2NmMjFmNzFjMDY3YjYpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWI0MjNhNDBlOWVjNDZkNTk2NTg2N2FhNjY0ZDg4NzIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NTUxOTEsMC4xNzM0NTNdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiIzgwZmZiNCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiM4MGZmYjQiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfOWExZDViNjg1YjdmNDdkNzkwMThiOGE3OWZmNDFiMmQgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMjZkZTVmZmI2MWYyNDdjYjgyNGZkOGY3YjQ5MWNiOWMgPSAkKCc8ZGl2IGlkPSJodG1sXzI2ZGU1ZmZiNjFmMjQ3Y2I4MjRmZDhmN2I0OTFjYjljIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5FYXN0YnJvb2sgQ2x1c3RlciAzPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF85YTFkNWI2ODViN2Y0N2Q3OTAxOGI4YTc5ZmY0MWIyZC5zZXRDb250ZW50KGh0bWxfMjZkZTVmZmI2MWYyNDdjYjgyNGZkOGY3YjQ5MWNiOWMpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfNWI0MjNhNDBlOWVjNDZkNTk2NTg2N2FhNjY0ZDg4NzIuYmluZFBvcHVwKHBvcHVwXzlhMWQ1YjY4NWI3ZjQ3ZDc5MDE4YjhhNzlmZjQxYjJkKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2E2YjcxMTg0YjM0MTQ0NTg5MjYyNTE2ZGQ1MzNkMmJmID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTM1ODA5LDAuMTA0NzU1OTk5OTk5OTk5OTldLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiIzgwMDBmZiIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiM4MDAwZmYiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNzRmYWM2N2U1YTY3NDRmZDljMmMwZDhmODkyNTAyYTQgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNTMxOTc3YWRmYzRlNDgwYThjYjBiNDQwOGVmNDkzYWQgPSAkKCc8ZGl2IGlkPSJodG1sXzUzMTk3N2FkZmM0ZTQ4MGE4Y2IwYjQ0MDhlZjQ5M2FkIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5FYXN0YnVyeSBDbHVzdGVyIDE8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzc0ZmFjNjdlNWE2NzQ0ZmQ5YzJjMGQ4Zjg5MjUwMmE0LnNldENvbnRlbnQoaHRtbF81MzE5NzdhZGZjNGU0ODBhOGNiMGI0NDA4ZWY0OTNhZCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9hNmI3MTE4NGIzNDE0NDU4OTI2MjUxNmRkNTMzZDJiZi5iaW5kUG9wdXAocG9wdXBfNzRmYWM2N2U1YTY3NDRmZDljMmMwZDhmODkyNTAyYTQpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfNWQ4YmE3ZDNlYzBjNDU0Y2FkNTdlOTA4NmQ5MzBjOTIgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41MzI1ODEsMC4wODU3MDRdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiIzgwMDBmZiIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiM4MDAwZmYiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfMTM0OTlmMjM3NGIxNGU0MGIxYzlkZDg5ZTc5Nzk4YzEgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfM2M4ODE5YTk5YjhjNDM0ZDljZjQ5NDcwZjdlNDAzYzMgPSAkKCc8ZGl2IGlkPSJodG1sXzNjODgxOWE5OWI4YzQzNGQ5Y2Y0OTQ3MGY3ZTQwM2MzIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5HYXNjb2lnbmUgQ2x1c3RlciAxPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF8xMzQ5OWYyMzc0YjE0ZTQwYjFjOWRkODllNzk3OThjMS5zZXRDb250ZW50KGh0bWxfM2M4ODE5YTk5YjhjNDM0ZDljZjQ5NDcwZjdlNDAzYzMpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfNWQ4YmE3ZDNlYzBjNDU0Y2FkNTdlOTA4NmQ5MzBjOTIuYmluZFBvcHVwKHBvcHVwXzEzNDk5ZjIzNzRiMTRlNDBiMWM5ZGQ4OWU3OTc5OGMxKTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyXzJhMjkyNDcyNzQ0NzQwN2JiOWQ3ZTZjOTU2OWVlMmNjID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTM2MDQxLDAuMTMyNjQxXSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogIiMwMGI1ZWIiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICIjMDBiNWViIiwKICAiZmlsbE9wYWNpdHkiOiAwLjcsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMS4wLAogICJyYWRpdXMiOiA1LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzc2NjNjNDJlNTMyZjRiYzY4NThjMDM4MTE4Y2I0NGU1KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwX2NlMGJmNzcxYmEzNjQ2MjRhOGZkNjQ2NmU2ODY5M2Q2ID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2M2MzQzYTYwNGY5YzQ3ZjY5ZDNkNjZiY2JmNjkxMzNjID0gJCgnPGRpdiBpZD0iaHRtbF9jNjM0M2E2MDRmOWM0N2Y2OWQzZDY2YmNiZjY5MTMzYyIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+R29yZXNicm9vayBDbHVzdGVyIDI8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2NlMGJmNzcxYmEzNjQ2MjRhOGZkNjQ2NmU2ODY5M2Q2LnNldENvbnRlbnQoaHRtbF9jNjM0M2E2MDRmOWM0N2Y2OWQzZDY2YmNiZjY5MTMzYyk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl8yYTI5MjQ3Mjc0NDc0MDdiYjlkN2U2Yzk1NjllZTJjYy5iaW5kUG9wdXAocG9wdXBfY2UwYmY3NzFiYTM2NDYyNGE4ZmQ2NDY2ZTY4NjkzZDYpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfZDhlYTljYTQ5NzQxNGM2OTllMWNkZDdhOGQ0NTU3MDYgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NTg2ODksMC4xNTI5MzA5OTk5OTk5OTk5OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICIjMDBiNWViIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzAwYjVlYiIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF80NWEzM2MwM2FkODc0MDc5YmNjNTI4OTBlNzUwOWIxMyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8yNGNhMGZlNGFlZTY0ODBhODZiZGNhODA5M2ZiOWY5ZCA9ICQoJzxkaXYgaWQ9Imh0bWxfMjRjYTBmZTRhZWU2NDgwYTg2YmRjYTgwOTNmYjlmOWQiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPkhlYXRoIENsdXN0ZXIgMjwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNDVhMzNjMDNhZDg3NDA3OWJjYzUyODkwZTc1MDliMTMuc2V0Q29udGVudChodG1sXzI0Y2EwZmU0YWVlNjQ4MGE4NmJkY2E4MDkzZmI5ZjlkKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2Q4ZWE5Y2E0OTc0MTRjNjk5ZTFjZGQ3YThkNDU1NzA2LmJpbmRQb3B1cChwb3B1cF80NWEzM2MwM2FkODc0MDc5YmNjNTI4OTBlNzUwOWIxMyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9mMjY0ZmUxODQ4NTI0YmU3YmQzZGZkNzBlMWIwMTFmOCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjU0NDQzLDAuMDkzNjQ0XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogIiMwMGI1ZWIiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICIjMDBiNWViIiwKICAiZmlsbE9wYWNpdHkiOiAwLjcsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMS4wLAogICJyYWRpdXMiOiA1LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzc2NjNjNDJlNTMyZjRiYzY4NThjMDM4MTE4Y2I0NGU1KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzA1M2ZiYTgwZjA4MzQzZjlhOTVlYWFkYTQxY2U4YmQ1ID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sX2NiZmRmNDg5YjVmMzQ4YjlhMjU3ZjA2NzBjYTEwZGU4ID0gJCgnPGRpdiBpZD0iaHRtbF9jYmZkZjQ4OWI1ZjM0OGI5YTI1N2YwNjcwY2ExMGRlOCIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+TG9uZ2JyaWRnZSBDbHVzdGVyIDI8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwXzA1M2ZiYTgwZjA4MzQzZjlhOTVlYWFkYTQxY2U4YmQ1LnNldENvbnRlbnQoaHRtbF9jYmZkZjQ4OWI1ZjM0OGI5YTI1N2YwNjcwY2ExMGRlOCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9mMjY0ZmUxODQ4NTI0YmU3YmQzZGZkNzBlMWIwMTFmOC5iaW5kUG9wdXAocG9wdXBfMDUzZmJhODBmMDgzNDNmOWE5NWVhYWRhNDFjZThiZDUpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfMTU4OWIwMjAzNWY1NGY5NDkwN2FmODViZTU2NjcyMjAgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NDUxODksMC4xMjAzMzJdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiIzgwZmZiNCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiM4MGZmYjQiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfZDg1MzVkMGFjNzBlNDY1OTgxNmE2MjkyMDIwZDY4ZjkgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfNDYyYjA0YjE0N2I1NDg0YWFiOGIyZTNhMDdjZTYzNDQgPSAkKCc8ZGl2IGlkPSJodG1sXzQ2MmIwNGIxNDdiNTQ4NGFhYjhiMmUzYTA3Y2U2MzQ0IiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5NYXllc2Jyb29rIENsdXN0ZXIgMzwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfZDg1MzVkMGFjNzBlNDY1OTgxNmE2MjkyMDIwZDY4Zjkuc2V0Q29udGVudChodG1sXzQ2MmIwNGIxNDdiNTQ4NGFhYjhiMmUzYTA3Y2U2MzQ0KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzE1ODliMDIwMzVmNTRmOTQ5MDdhZjg1YmU1NjY3MjIwLmJpbmRQb3B1cChwb3B1cF9kODUzNWQwYWM3MGU0NjU5ODE2YTYyOTIwMjBkNjhmOSk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8zMzkyN2NlMTA2ZDQ0YWUyYWNlNjQxZTQ4YjE1ZDVkMCA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjU0OTgzMSwwLjEzNTM0OF0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICIjODAwMGZmIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzgwMDBmZiIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9jMjY3ZGNkNjcwMDc0NGZhYmU0NWRhOTBiYTI0NTg1YyA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF9kNTE3NGNlMjc1MTc0YWNkOGExNGVlNjM5ODU4OGU2NyA9ICQoJzxkaXYgaWQ9Imh0bWxfZDUxNzRjZTI3NTE3NGFjZDhhMTRlZTYzOTg1ODhlNjciIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPlBhcnNsb2VzIENsdXN0ZXIgMTwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfYzI2N2RjZDY3MDA3NDRmYWJlNDVkYTkwYmEyNDU4NWMuc2V0Q29udGVudChodG1sX2Q1MTc0Y2UyNzUxNzRhY2Q4YTE0ZWU2Mzk4NTg4ZTY3KTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzMzOTI3Y2UxMDZkNDRhZTJhY2U2NDFlNDhiMTVkNWQwLmJpbmRQb3B1cChwb3B1cF9jMjY3ZGNkNjcwMDc0NGZhYmU0NWRhOTBiYTI0NTg1Yyk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl83YTlkYjg4MjNmNWQ0MjA1YjlhN2EyYjVlNTRjMGJiZSA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUyNDUwMjAwMDAwMDAwNSwwLjE1MjY0NV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICIjZmZiMzYwIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiI2ZmYjM2MCIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9hMWI1Yjc3ZmQzOWM0ZTA4ODY3ODI0MjM1Y2YxMTgwNiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF84Y2EyMzQwMTViYzk0ZjQ5YjJkZjlmYmQ3Y2Q1NTdiZiA9ICQoJzxkaXYgaWQ9Imh0bWxfOGNhMjM0MDE1YmM5NGY0OWIyZGY5ZmJkN2NkNTU3YmYiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPlJpdmVyIENsdXN0ZXIgNDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfYTFiNWI3N2ZkMzljNGUwODg2NzgyNDIzNWNmMTE4MDYuc2V0Q29udGVudChodG1sXzhjYTIzNDAxNWJjOTRmNDliMmRmOWZiZDdjZDU1N2JmKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzdhOWRiODgyM2Y1ZDQyMDViOWE3YTJiNWU1NGMwYmJlLmJpbmRQb3B1cChwb3B1cF9hMWI1Yjc3ZmQzOWM0ZTA4ODY3ODI0MjM1Y2YxMTgwNik7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl9kYTE2NTgxYjkwY2M0NTFlYTQ4MDc5Y2Y1MTNhYmVlZiA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjUyNDA3OCwwLjExOTc0Ml0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICIjMDBiNWViIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzAwYjVlYiIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9mYzU1OWIwOWJmZDU0MTE2OGYyMzliZTYwNzYyODMwNiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF84ZGJhNzkwNTY3NjE0MTUxYjg4NmY4NTk0OWE1NTdhNiA9ICQoJzxkaXYgaWQ9Imh0bWxfOGRiYTc5MDU2NzYxNDE1MWI4ODZmODU5NDlhNTU3YTYiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPlRoYW1lcyBDbHVzdGVyIDI8L2Rpdj4nKVswXTsKICAgICAgICAgICAgICAgIHBvcHVwX2ZjNTU5YjA5YmZkNTQxMTY4ZjIzOWJlNjA3NjI4MzA2LnNldENvbnRlbnQoaHRtbF84ZGJhNzkwNTY3NjE0MTUxYjg4NmY4NTk0OWE1NTdhNik7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgY2lyY2xlX21hcmtlcl9kYTE2NTgxYjkwY2M0NTFlYTQ4MDc5Y2Y1MTNhYmVlZi5iaW5kUG9wdXAocG9wdXBfZmM1NTliMDliZmQ1NDExNjhmMjM5YmU2MDc2MjgzMDYpOwoKICAgICAgICAgICAgCiAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIGNpcmNsZV9tYXJrZXJfYjhhNzhhMzE1OWE3NDRmZThjNDhlOWYxNmQ3MjQ5NjkgPSBMLmNpcmNsZU1hcmtlcigKICAgICAgICAgICAgICAgIFs1MS41NjEyMywwLjEzNTkyNV0sCiAgICAgICAgICAgICAgICB7CiAgImJ1YmJsaW5nTW91c2VFdmVudHMiOiB0cnVlLAogICJjb2xvciI6ICIjODAwMGZmIiwKICAiZGFzaEFycmF5IjogbnVsbCwKICAiZGFzaE9mZnNldCI6IG51bGwsCiAgImZpbGwiOiB0cnVlLAogICJmaWxsQ29sb3IiOiAiIzgwMDBmZiIsCiAgImZpbGxPcGFjaXR5IjogMC43LAogICJmaWxsUnVsZSI6ICJldmVub2RkIiwKICAibGluZUNhcCI6ICJyb3VuZCIsCiAgImxpbmVKb2luIjogInJvdW5kIiwKICAib3BhY2l0eSI6IDEuMCwKICAicmFkaXVzIjogNSwKICAic3Ryb2tlIjogdHJ1ZSwKICAid2VpZ2h0IjogMwp9CiAgICAgICAgICAgICAgICApLmFkZFRvKG1hcF83NjYzYzQyZTUzMmY0YmM2ODU4YzAzODExOGNiNDRlNSk7CiAgICAgICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBwb3B1cF9hNDY1Nzc4ODIwMzE0MDNmOTg4MDE1Y2Q3Yzc1ZTExNiA9IEwucG9wdXAoe21heFdpZHRoOiAnMzAwJ30pOwoKICAgICAgICAgICAgCiAgICAgICAgICAgICAgICB2YXIgaHRtbF8wNmZmMmJjNjZlMTY0NThhODYxOGE1NDI5ZGNjM2YzYiA9ICQoJzxkaXYgaWQ9Imh0bWxfMDZmZjJiYzY2ZTE2NDU4YTg2MThhNTQyOWRjYzNmM2IiIHN0eWxlPSJ3aWR0aDogMTAwLjAlOyBoZWlnaHQ6IDEwMC4wJTsiPlZhbGVuY2UgQ2x1c3RlciAxPC9kaXY+JylbMF07CiAgICAgICAgICAgICAgICBwb3B1cF9hNDY1Nzc4ODIwMzE0MDNmOTg4MDE1Y2Q3Yzc1ZTExNi5zZXRDb250ZW50KGh0bWxfMDZmZjJiYzY2ZTE2NDU4YTg2MThhNTQyOWRjYzNmM2IpOwogICAgICAgICAgICAKCiAgICAgICAgICAgIGNpcmNsZV9tYXJrZXJfYjhhNzhhMzE1OWE3NDRmZThjNDhlOWYxNmQ3MjQ5NjkuYmluZFBvcHVwKHBvcHVwX2E0NjU3Nzg4MjAzMTQwM2Y5ODgwMTVjZDdjNzVlMTE2KTsKCiAgICAgICAgICAgIAogICAgICAgIAogICAgCiAgICAgICAgICAgIHZhciBjaXJjbGVfbWFya2VyX2VkN2I3NWQ3MjE4NjRjZjhiZDlkNmMzNmE2ZmNiN2VhID0gTC5jaXJjbGVNYXJrZXIoCiAgICAgICAgICAgICAgICBbNTEuNTM2NTkwOTk5OTk5OTk0LDAuMTY2NjEwOTk5OTk5OTk5OThdLAogICAgICAgICAgICAgICAgewogICJidWJibGluZ01vdXNlRXZlbnRzIjogdHJ1ZSwKICAiY29sb3IiOiAiI2ZmMDAwMCIsCiAgImRhc2hBcnJheSI6IG51bGwsCiAgImRhc2hPZmZzZXQiOiBudWxsLAogICJmaWxsIjogdHJ1ZSwKICAiZmlsbENvbG9yIjogIiNmZjAwMDAiLAogICJmaWxsT3BhY2l0eSI6IDAuNywKICAiZmlsbFJ1bGUiOiAiZXZlbm9kZCIsCiAgImxpbmVDYXAiOiAicm91bmQiLAogICJsaW5lSm9pbiI6ICJyb3VuZCIsCiAgIm9wYWNpdHkiOiAxLjAsCiAgInJhZGl1cyI6IDUsCiAgInN0cm9rZSI6IHRydWUsCiAgIndlaWdodCI6IDMKfQogICAgICAgICAgICAgICAgKS5hZGRUbyhtYXBfNzY2M2M0MmU1MzJmNGJjNjg1OGMwMzgxMThjYjQ0ZTUpOwogICAgICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgcG9wdXBfNDY1YjllYjkwNzkxNDNmN2FiNzc2YmI4YmQ3YzliNjQgPSBMLnBvcHVwKHttYXhXaWR0aDogJzMwMCd9KTsKCiAgICAgICAgICAgIAogICAgICAgICAgICAgICAgdmFyIGh0bWxfMWRhMTQwMzYwMmM0NGVjZGFhMDhjZWI3ZDZlNzA5NGEgPSAkKCc8ZGl2IGlkPSJodG1sXzFkYTE0MDM2MDJjNDRlY2RhYTA4Y2ViN2Q2ZTcwOTRhIiBzdHlsZT0id2lkdGg6IDEwMC4wJTsgaGVpZ2h0OiAxMDAuMCU7Ij5WaWxsYWdlIENsdXN0ZXIgMDwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfNDY1YjllYjkwNzkxNDNmN2FiNzc2YmI4YmQ3YzliNjQuc2V0Q29udGVudChodG1sXzFkYTE0MDM2MDJjNDRlY2RhYTA4Y2ViN2Q2ZTcwOTRhKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyX2VkN2I3NWQ3MjE4NjRjZjhiZDlkNmMzNmE2ZmNiN2VhLmJpbmRQb3B1cChwb3B1cF80NjViOWViOTA3OTE0M2Y3YWI3NzZiYjhiZDdjOWI2NCk7CgogICAgICAgICAgICAKICAgICAgICAKICAgIAogICAgICAgICAgICB2YXIgY2lyY2xlX21hcmtlcl8yNDBiNGQwMGMxNDA0MmEwYWVjMDM5ZjMwNzEyOWE5NyA9IEwuY2lyY2xlTWFya2VyKAogICAgICAgICAgICAgICAgWzUxLjU2ODI3MiwwLjE0MTkxMDk5OTk5OTk5OTk4XSwKICAgICAgICAgICAgICAgIHsKICAiYnViYmxpbmdNb3VzZUV2ZW50cyI6IHRydWUsCiAgImNvbG9yIjogIiMwMGI1ZWIiLAogICJkYXNoQXJyYXkiOiBudWxsLAogICJkYXNoT2Zmc2V0IjogbnVsbCwKICAiZmlsbCI6IHRydWUsCiAgImZpbGxDb2xvciI6ICIjMDBiNWViIiwKICAiZmlsbE9wYWNpdHkiOiAwLjcsCiAgImZpbGxSdWxlIjogImV2ZW5vZGQiLAogICJsaW5lQ2FwIjogInJvdW5kIiwKICAibGluZUpvaW4iOiAicm91bmQiLAogICJvcGFjaXR5IjogMS4wLAogICJyYWRpdXMiOiA1LAogICJzdHJva2UiOiB0cnVlLAogICJ3ZWlnaHQiOiAzCn0KICAgICAgICAgICAgICAgICkuYWRkVG8obWFwXzc2NjNjNDJlNTMyZjRiYzY4NThjMDM4MTE4Y2I0NGU1KTsKICAgICAgICAgICAgCiAgICAKICAgICAgICAgICAgdmFyIHBvcHVwXzdjNDg3ODc3OTc5MzQ4MDY5NThmZWIwMmU0MWZiMDYyID0gTC5wb3B1cCh7bWF4V2lkdGg6ICczMDAnfSk7CgogICAgICAgICAgICAKICAgICAgICAgICAgICAgIHZhciBodG1sXzUzMzQ0MmM1MzM2MTQyZGNiN2RhYTNiZTI1MzgxOGQyID0gJCgnPGRpdiBpZD0iaHRtbF81MzM0NDJjNTMzNjE0MmRjYjdkYWEzYmUyNTM4MThkMiIgc3R5bGU9IndpZHRoOiAxMDAuMCU7IGhlaWdodDogMTAwLjAlOyI+V2hhbGVib25lIENsdXN0ZXIgMjwvZGl2PicpWzBdOwogICAgICAgICAgICAgICAgcG9wdXBfN2M0ODc4Nzc5NzkzNDgwNjk1OGZlYjAyZTQxZmIwNjIuc2V0Q29udGVudChodG1sXzUzMzQ0MmM1MzM2MTQyZGNiN2RhYTNiZTI1MzgxOGQyKTsKICAgICAgICAgICAgCgogICAgICAgICAgICBjaXJjbGVfbWFya2VyXzI0MGI0ZDAwYzE0MDQyYTBhZWMwMzlmMzA3MTI5YTk3LmJpbmRQb3B1cChwb3B1cF83YzQ4Nzg3Nzk3OTM0ODA2OTU4ZmViMDJlNDFmYjA2Mik7CgogICAgICAgICAgICAKICAgICAgICAKPC9zY3JpcHQ+" style="position:absolute;width:100%;height:100%;left:0;top:0;border:none !important;" allowfullscreen webkitallowfullscreen mozallowfullscreen></iframe></div></div>



[back to the top](#top)

### **Results and Discussion** <a name="results"></a>


My examination contains data coming from different aspects.

During the analysis I found that 
- the most populated areas are Cities, however the conurbation is the least which was against my expectations. I expected to the rural site would be the least populated areas. There is a chance that country people are moving closer to the cities but the city itself is already to crowded or expensive to them
- that can be the reason why my other expectation was wrong again. Not the City is which have the highest population density among the observed areas. Maybe they are too expensive to live maybe it has another reason, the finf the reason was not part of this project. Hamlets are still the least crowded area, no surprise on this.
- When it comes the average age of the observed areas I found something which can reinforce my assumption taken before. The conurbation area have the youth. So it can mean that the younger generation is moving there from the rural.
- No surprise: a lot of poeple are out there in the conurbation so the most of the crimes are commited in here. The presence of the police might have more patrol in the inner city or maybe the conurbation area is just too big to supervise.
- I assume that a lot of people move to conurbation recently. This can be the explanation of the high average price, also it can explain the density
- Despite the observations made before the conurbation area has the least sales volume.

The clusters enlightened the question from another point of view. 

Since I filtered the dataframe before, all the clusters are very similar, however we can find the differences. Some clusters seem to be more approachable with public transport, and the others are more "picnic" friendly.


[back to the top](#top)


### **Conclusion** <a name="conclusion"></a>

There are a lot of questions out there which were not covered by my analysis but that is okay. 

I just wanted to find the area which attributes looks good enough to check the field personally.

Based on the data and the clusters information I would check **Cluster 1** and **Cluster 2**. According the data and the venues information they seem work to me.

They both approachable with public transport which is neccessary to me. 
Also they have places which can make the weekdays easier.

Right now I am satisfied with the results so I would check **Cluster 1** at first.


[back to the top](#top)
